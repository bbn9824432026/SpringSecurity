# SecurityContext Architecture - Configuration & Customization Guide

## 1. SecurityContext Core Components

### 1.1 SecurityContextHolder Structure
```java
SecurityContextHolder
├── SecurityContextHolderStrategy (storage strategy)
├── SecurityContext (current context)
├── initializeCount (initialization counter)
└── strategyName (current strategy name)
```

### 1.2 Available Storage Strategies
```java
// Thread-local storage (default)
ThreadLocalSecurityContextHolderStrategy

// Inheritable thread-local storage
InheritableThreadLocalSecurityContextHolderStrategy

// Global storage (single context for entire JVM)
GlobalSecurityContextHolderStrategy

// Custom strategy
CustomSecurityContextHolderStrategy
```

## 2. Configuration Methods

### 2.1 System Property Configuration
```java
// Set strategy via system property
System.setProperty(SecurityContextHolder.SYSTEM_PROPERTY, 
    SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);

// Available modes:
// - MODE_THREADLOCAL (default)
// - MODE_INHERITABLETHREADLOCAL
// - MODE_GLOBAL
```

### 2.2 Programmatic Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @PostConstruct
    public void configureSecurityContextStrategy() {
        // Set strategy programmatically
        SecurityContextHolder.setStrategyName(
            SecurityContextHolder.MODE_INHERITABLETHREADLOCAL
        );
    }
}
```

### 2.3 Custom Strategy Implementation
```java
public class CustomSecurityContextHolderStrategy 
    implements SecurityContextHolderStrategy {
    
    private final Map<String, SecurityContext> contextMap = 
        new ConcurrentHashMap<>();
    
    @Override
    public void clearContext() {
        String key = getCurrentKey();
        contextMap.remove(key);
    }
    
    @Override
    public SecurityContext getContext() {
        String key = getCurrentKey();
        SecurityContext context = contextMap.get(key);
        if (context == null) {
            context = createEmptyContext();
            contextMap.put(key, context);
        }
        return context;
    }
    
    @Override
    public void setContext(SecurityContext context) {
        String key = getCurrentKey();
        if (context == null) {
            contextMap.remove(key);
        } else {
            contextMap.put(key, context);
        }
    }
    
    @Override
    public SecurityContext createEmptyContext() {
        return new SecurityContextImpl();
    }
    
    private String getCurrentKey() {
        // Custom logic to determine context key
        // Could be based on tenant, user, request, etc.
        return Thread.currentThread().getName() + "-" + getCurrentTenant();
    }
    
    private String getCurrentTenant() {
        // Implementation to get current tenant
        return "default";
    }
}

// Register custom strategy
@Configuration
public class CustomSecurityContextConfig {
    
    @PostConstruct
    public void configureCustomStrategy() {
        SecurityContextHolder.setStrategyName("custom");
        SecurityContextHolder.setStrategy(new CustomSecurityContextHolderStrategy());
    }
}
```

## 3. SecurityContextRepository Customization

### 3.1 Available Repository Implementations
```java
// HTTP Session based (default)
HttpSessionSecurityContextRepository

// No persistence
NullSecurityContextRepository

// Delegating repository
DelegatingSecurityContextRepository

// Custom repository
CustomSecurityContextRepository
```

### 3.2 Custom SecurityContextRepository
```java
@Component
public class RedisSecurityContextRepository implements SecurityContextRepository {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CONTEXT_KEY_PREFIX = "security:context:";
    
    @Override
    public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
        HttpServletRequest request = requestResponseHolder.getRequest();
        String sessionId = getSessionId(request);
        
        if (sessionId != null) {
            SecurityContext context = (SecurityContext) redisTemplate
                .opsForValue()
                .get(CONTEXT_KEY_PREFIX + sessionId);
            
            if (context != null) {
                return context;
            }
        }
        
        return SecurityContextHolder.createEmptyContext();
    }
    
    @Override
    public void saveContext(SecurityContext context, HttpServletRequest request, 
                          HttpServletResponse response) {
        String sessionId = getSessionId(request);
        
        if (sessionId != null) {
            if (context.getAuthentication() == null || 
                context.getAuthentication() instanceof AnonymousAuthenticationToken) {
                redisTemplate.delete(CONTEXT_KEY_PREFIX + sessionId);
            } else {
                redisTemplate.opsForValue().set(
                    CONTEXT_KEY_PREFIX + sessionId, 
                    context, 
                    Duration.ofMinutes(30)
                );
            }
        }
    }
    
    @Override
    public boolean containsContext(HttpServletRequest request) {
        String sessionId = getSessionId(request);
        return sessionId != null && 
               redisTemplate.hasKey(CONTEXT_KEY_PREFIX + sessionId);
    }
    
    private String getSessionId(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        return session != null ? session.getId() : null;
    }
}
```

### 3.3 JWT-based SecurityContextRepository
```java
@Component
public class JwtSecurityContextRepository implements SecurityContextRepository {
    
    @Autowired
    private JwtService jwtService;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
        HttpServletRequest request = requestResponseHolder.getRequest();
        String token = extractToken(request);
        
        if (token != null && jwtService.validateToken(token)) {
            String username = jwtService.extractUsername(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());
            
            SecurityContext context = SecurityContextHolder.createEmptyContext();
            context.setAuthentication(authentication);
            return context;
        }
        
        return SecurityContextHolder.createEmptyContext();
    }
    
    @Override
    public void saveContext(SecurityContext context, HttpServletRequest request, 
                          HttpServletResponse response) {
        // JWT is stateless, no need to save context
        // Optional: refresh token logic can be implemented here
    }
    
    @Override
    public boolean containsContext(HttpServletRequest request) {
        String token = extractToken(request);
        return token != null && jwtService.validateToken(token);
    }
    
    private String extractToken(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
}
```

## 4. Configuration in Spring Security

### 4.1 HttpSecurity Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityContextRepository securityContextRepository() {
        return new RedisSecurityContextRepository();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .securityContext(securityContext -> 
                securityContext
                    .securityContextRepository(securityContextRepository())
                    .requireExplicitSave(true) // For stateless applications
            )
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .build();
    }
}
```

### 4.2 Multi-Repository Configuration
```java
@Bean
public SecurityContextRepository delegatingSecurityContextRepository() {
    return new DelegatingSecurityContextRepository(
        new RequestAttributeSecurityContextRepository(),
        new HttpSessionSecurityContextRepository()
    );
}
```

## 5. Custom SecurityContext Implementation

### 5.1 Enhanced SecurityContext
```java
public class TenantAwareSecurityContext implements SecurityContext {
    
    private Authentication authentication;
    private String tenantId;
    private Map<String, Object> attributes = new HashMap<>();
    
    @Override
    public Authentication getAuthentication() {
        return authentication;
    }
    
    @Override
    public void setAuthentication(Authentication authentication) {
        this.authentication = authentication;
    }
    
    // Custom methods
    public String getTenantId() {
        return tenantId;
    }
    
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    
    public void setAttribute(String key, Object value) {
        attributes.put(key, value);
    }
    
    public Object getAttribute(String key) {
        return attributes.get(key);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TenantAwareSecurityContext) {
            TenantAwareSecurityContext other = (TenantAwareSecurityContext) obj;
            return Objects.equals(authentication, other.authentication) &&
                   Objects.equals(tenantId, other.tenantId);
        }
        return false;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(authentication, tenantId);
    }
    
    @Override
    public String toString() {
        return "TenantAwareSecurityContext{" +
               "authentication=" + authentication +
               ", tenantId='" + tenantId + '\'' +
               '}';
    }
}
```

### 5.2 Custom SecurityContext Factory
```java
@Component
public class TenantAwareSecurityContextFactory {
    
    public TenantAwareSecurityContext createContext(Authentication authentication, 
                                                   String tenantId) {
        TenantAwareSecurityContext context = new TenantAwareSecurityContext();
        context.setAuthentication(authentication);
        context.setTenantId(tenantId);
        return context;
    }
    
    public TenantAwareSecurityContext getCurrentContext() {
        SecurityContext context = SecurityContextHolder.getContext();
        if (context instanceof TenantAwareSecurityContext) {
            return (TenantAwareSecurityContext) context;
        }
        return null;
    }
}
```

## 6. Use Cases and Implementation Scenarios

### 6.1 Multi-Tenant Applications
```java
@Component
public class TenantSecurityContextHolder {
    
    private static final String TENANT_CONTEXT_KEY = "TENANT_ID";
    
    public static void setCurrentTenant(String tenantId) {
        TenantAwareSecurityContext context = getCurrentTenantContext();
        context.setTenantId(tenantId);
        SecurityContextHolder.setContext(context);
    }
    
    public static String getCurrentTenant() {
        TenantAwareSecurityContext context = getCurrentTenantContext();
        return context != null ? context.getTenantId() : null;
    }
    
    private static TenantAwareSecurityContext getCurrentTenantContext() {
        SecurityContext context = SecurityContextHolder.getContext();
        if (!(context instanceof TenantAwareSecurityContext)) {
            TenantAwareSecurityContext tenantContext = new TenantAwareSecurityContext();
            tenantContext.setAuthentication(context.getAuthentication());
            SecurityContextHolder.setContext(tenantContext);
            return tenantContext;
        }
        return (TenantAwareSecurityContext) context;
    }
}

// Usage in filter
@Component
public class TenantResolutionFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        String tenantId = extractTenantId(httpRequest);
        if (tenantId != null) {
            TenantSecurityContextHolder.setCurrentTenant(tenantId);
        }
        
        try {
            chain.doFilter(request, response);
        } finally {
            // Clean up tenant context
            SecurityContextHolder.clearContext();
        }
    }
    
    private String extractTenantId(HttpServletRequest request) {
        // Extract tenant from header, subdomain, or path
        return request.getHeader("X-Tenant-ID");
    }
}
```

### 6.2 Microservices Context Propagation
```java
@Component
public class MicroserviceSecurityContextPropagator {
    
    public void propagateContext(String targetService) {
        SecurityContext context = SecurityContextHolder.getContext();
        
        if (context.getAuthentication() != null) {
            // Create JWT token with current context
            String token = createJwtToken(context.getAuthentication());
            
            // Set in request headers for downstream services
            RequestContextHolder.currentRequestAttributes()
                .setAttribute("Authorization", "Bearer " + token, 
                            RequestAttributes.SCOPE_REQUEST);
        }
    }
    
    private String createJwtToken(Authentication authentication) {
        // JWT creation logic
        return "jwt-token";
    }
}
```

### 6.3 Async Processing Context
```java
@Service
public class AsyncSecurityService {
    
    @Async("taskExecutor")
    @PreAuthorize("hasRole('ADMIN')")
    public CompletableFuture<String> processAsync() {
        // Security context is automatically propagated in async methods
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        
        return CompletableFuture.completedFuture(
            "Processed by: " + auth.getName()
        );
    }
}

// Configuration for async security context propagation
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        
        // Enable security context propagation
        executor.setTaskDecorator(new SecurityContextPropagatingTaskDecorator());
        
        executor.initialize();
        return executor;
    }
}

// Custom task decorator for security context
public class SecurityContextPropagatingTaskDecorator implements TaskDecorator {
    
    @Override
    public Runnable decorate(Runnable runnable) {
        SecurityContext context = SecurityContextHolder.getContext();
        
        return () -> {
            try {
                SecurityContextHolder.setContext(context);
                runnable.run();
            } finally {
                SecurityContextHolder.clearContext();
            }
        };
    }
}
```

### 6.4 Testing with Custom SecurityContext
```java
@TestConfiguration
public class TestSecurityConfig {
    
    @Bean
    @Primary
    public SecurityContextRepository testSecurityContextRepository() {
        return new InMemorySecurityContextRepository();
    }
}

@ExtendWith(SpringExtension.class)
@SpringBootTest
class SecurityContextTest {
    
    @Test
    @WithMockUser(username = "testuser", roles = {"USER"})
    void testWithMockUser() {
        SecurityContext context = SecurityContextHolder.getContext();
        Authentication auth = context.getAuthentication();
        
        assertThat(auth.getName()).isEqualTo("testuser");
        assertThat(auth.getAuthorities()).hasSize(1);
    }
    
    @Test
    void testWithCustomSecurityContext() {
        // Create custom security context
        TenantAwareSecurityContext context = new TenantAwareSecurityContext();
        context.setAuthentication(createTestAuthentication());
        context.setTenantId("test-tenant");
        
        SecurityContextHolder.setContext(context);
        
        // Test logic here
        assertThat(TenantSecurityContextHolder.getCurrentTenant())
            .isEqualTo("test-tenant");
        
        SecurityContextHolder.clearContext();
    }
    
    private Authentication createTestAuthentication() {
        return new UsernamePasswordAuthenticationToken(
            "testuser", 
            "password", 
            List.of(new SimpleGrantedAuthority("ROLE_USER"))
        );
    }
}
```

## 7. Performance Considerations and Best Practices

### 7.1 Context Lifecycle Management
```java
@Component
public class SecurityContextLifecycleManager {
    
    public void createContext(Authentication authentication) {
        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        SecurityContextHolder.setContext(context);
    }
    
    public void clearContext() {
        SecurityContextHolder.clearContext();
    }
    
    public void copyContext(SecurityContext sourceContext) {
        SecurityContext newContext = SecurityContextHolder.createEmptyContext();
        newContext.setAuthentication(sourceContext.getAuthentication());
        SecurityContextHolder.setContext(newContext);
    }
}
```

### 7.2 Context Serialization for Clustering
```java
public class SerializableSecurityContextImpl implements SecurityContext, Serializable {
    
    private static final long serialVersionUID = 1L;
    private Authentication authentication;
    
    @Override
    public Authentication getAuthentication() {
        return authentication;
    }
    
    @Override
    public void setAuthentication(Authentication authentication) {
        this.authentication = authentication;
    }
    
    // Custom serialization logic if needed
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
    }
    
    private void readObject(ObjectInputStream in) 
        throws IOException, ClassNotFoundException {
        in.defaultReadObject();
    }
}
```

This comprehensive guide covers all aspects of SecurityContext configuration, customization, and real-world use cases, providing you with the knowledge to implement sophisticated security context management in your applications.
